<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Draw over minimap renders.">
    <meta name="keywords" content="World of Warships, Minimap, Draw">
    <meta name="author" content="notyourfather">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Minimap Tactics</title>
    <link rel="stylesheet" href="/static/bootstrap.min.css">

    <script text="javascript" src="https://webtiming.github.io/timingsrc/lib/timingsrc-v2.js"></script>
    <script text="javascript" src="https://mcorp.no/lib/mediasync.js"></script>


    <!-- <script text="javascript" src="https://webtiming.github.io/timingsrc/doc/js/exp_mediasync.js"></script> -->

    <!-- <script>
        var run = function (timingProvider) {

            // timing object
            var to = new TIMINGSRC.TimingObject({ provider: timingProvider, range: [0, 100] });

            // set up button click handlers
            var buttonsElem = document.getElementById("buttons");
            var self = this;
            buttonsElem.onclick = function (e) {
                var elem, evt = e ? e : event;
                if (evt.srcElement) elem = evt.srcElement;
                else if (evt.target) elem = evt.target;
                if (elem.id === "pause") {
                    to.update({ velocity: 0.0 });
                }
                else if (elem.id === "tostart") {
                    to.update({ position: 0.0 });
                }
                else if (elem.id === "skipforward") {
                    to.update({ position: to.query().position + 5 });
                }
                else if (elem.id === "skipbackward") {
                    to.update({ position: to.query().position - 5 });
                }
                else if (elem.id === "forward") {
                    var v = to.query();
                    if (v.position === 100 && v.velocity === 0) {
                        to.update({ position: 0.0, velocity: 1.0 });
                    } else to.update({ velocity: 1.0 });
                }
                else if (elem.id === "toend") {
                    to.update({ position: 100.0 });
                }
            }

            // set up refresh of timingobject position
            to.on("timeupdate", function () {
                document.getElementById("position").innerHTML = to.query().position.toFixed(2);
            });

            // set up video sync
            var sync1 = MCorp.mediaSync(document.getElementById('video'), to);
        };
    </script> -->
    <style>
        body {
            background-color: #102031;
        }

        body::-webkit-scrollbar {
            display: none;
        }

        video {
            padding: 0;
        }

        .content {
            margin: 1.5em;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        #canvas {
            padding: 0;
            width: 800px;
            height: 850px;
            position: absolute !important;
            z-index: 10 !important;
        }
    </style>
</head>

<body>
    <div class="modal fade" id="settingControlsModal" tabindex="-1" role="dialog">
        <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Settings & Controls</h5>
                </div>
                <div class="modal-body">
                    <form>
                        <div class="row">
                            <div class="col">
                                <div class="form-group">
                                    <label for="lineColorPicker" class="form-label h6">Color picker</label>
                                    <input type="color" class="form-control form-control-color" id="lineColorPicker"
                                        value="#ffffff" style="height: 40px !important; width: 100% !important" />
                                </div>
                            </div>
                            <div class="col">
                                <div class="form-group">
                                    <label for="tool" class="form-label h6">Tool</label>
                                    <select class="form-control form-select" id="tool">
                                        <option value="line">Line</option>
                                        <option value="ellipse">Ellipse</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col">
                                <div class="form-group">
                                    <label for="lineStyle" class="form-label h6">Line Style</label>
                                    <select class="form-control form-select" id="lineStyle">
                                        <option value="solid">Solid</option>
                                        <option value="dashed">Dashed</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </form>
                    <table class="table table-borderless">
                        <thead>
                            <tr>
                                <th scope="col">Action</th>
                                <th scope="col">Key</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th scope="row">Show/Hide Option (this)</th>
                                <td>O</td>
                            </tr>
                            <tr>
                                <th scope="row">Clear lines</th>
                                <td>C</td>
                            </tr>
                            <tr>
                                <th scope="row">Clear lines (all clients)</th>
                                <td>ALT + C</td>
                            </tr>
                            <tr>
                                <th scope="row">Draw lines</th>
                                <td>RMB (hold) + movement</td>
                            </tr>
                            <tr>
                                <th scope="row">Ping</th>
                                <td>Double click</td>
                            </tr>
                            <tr>
                                <th scope="row">Seek forward</th>
                                <td>F</td>
                            </tr>
                            <tr>
                                <th scope="row">Seek backward</th>
                                <td>B</td>
                            </tr>
                            <tr>
                                <th scope="row">Play/Pause</th>
                                <td>P</td>
                            </tr>
                            <tr>
                                <th scope="row">Stop</th>
                                <td>S</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <div class="content">
        <canvas id="canvas"></canvas>
        <video id="minimap-video" src="{{video_url}}" width="800" height="850" muted preload></video>
    </div>
    <script type="text/javascript" src="https://www.mcorp.no/lib/mcorp-2.0.js"></script>
    <script type="text/javascript" src="/static/utils.js"></script>
    <script type="text/javascript" src="/static/jquery.min.js"></script>
    <script type="text/javascript" src="/static/socket.io.min.js"></script>
    <script type="text/javascript" src="/static/js.cookie.min.js"></script>
    <script type="text/javascript" src="/static/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src='/static/paper-full.min.js'></script>
    <script type='text/javascript'>
        const socket = io();
        const clients = new Map();
        // const video = document.getElementById("minimap-video");

        const tool = new paper.Tool();
        const strokeWidth = 3;
        const dash = [10, 10];
        const ghostOpacity = 0.5;


        var APPID_MCORP = "6651674759315626087";
        var app = MCorp.app(APPID_MCORP, { anon: true });
        app.run = function () {
            var to = new TIMINGSRC.TimingObject({ provider: app.motions.shared, range: [0, 100] });
            paper.view.onKeyUp = (event) => {
                switch (event.key) {
                    case "o":
                        $('#settingControlsModal').modal('toggle');
                        break;
                    case "p":
                        var v = to.query();
                        if (v.velocity === 1.0) {
                            to.update({ velocity: 0.0 });
                        } else {
                            to.update({ velocity: 1.0 });
                        }
                        break;
                    case "l":
                        var v = to.query();
                        if (v.position === 100 && v.velocity === 0) {
                            to.update({ position: 0.0, velocity: 1.0 });
                        } else to.update({ velocity: 1.0 });
                        break;
                    case "s":
                        to.update({ velocity: 0.0 });
                        to.update({ position: 0.0 });
                        break;
                    case "f":
                        to.update({ position: to.query().position + 1 });
                        break;
                    case "b":
                        to.update({ position: to.query().position - 1 });
                        break;
                }
            }
            var sync1 = MCorp.mediaSync(document.getElementById('minimap-video'), to);
        };
        app.init();

        paper.setup(document.getElementById("canvas"));
        tool.minDistance = 15;

        // function videoEventHandler(event) {
        //     socket.emit("event_video", { type: event.type, time: event.target.currentTime })
        // }

        // video.addEventListener("play", videoEventHandler);
        // video.addEventListener("pause", videoEventHandler);
        // video.addEventListener("seeked", videoEventHandler);

        function getClientSettings(event) {
            let color = $("#lineColorPicker").val();
            let style = $("#lineStyle").val();
            let tool = $("#tool").val();
            return {
                type: event.type,
                tool: tool,
                color: color,
                style: style,
                x: event.point.x,
                y: event.point.y
            };
        }

        function toolMouseEventHandler(event) {
            socket.emit("event_mouse", getClientSettings(event));
        }

        tool.onMouseDown = toolMouseEventHandler;
        tool.onMouseUp = toolMouseEventHandler;
        tool.onMouseDrag = toolMouseEventHandler;

        socket.on("connect", () => {
            console.log("connected!");
        })


        socket.on("client_left", (msg) => {
            let client_data = clients.get(msg)
            if (client_data && client_data.paths) {
                $.each(client_data.paths, (_, path) => {
                    path.remove();
                })
                $.each(client_data.shapes, (_, shape) => {
                    shape.remove();
                })
                clients.delete(msg);

            }
        })

        // socket.on("ev", (msg) => {
        //     console.log("I was called.");

        //     let isVideoPlaying = video.currentTime > 0 && !video.paused && !video.ended
        //         && video.readyState > video.HAVE_CURRENT_DATA;

        //     switch (msg.type) {
        //         case "play":
        //             if (!isVideoPlaying) {
        //                 video.play().catch(() => { });
        //             }
        //             break;
        //         case "pause":
        //             if (isVideoPlaying) {
        //                 video.currentTime = msg.time;
        //                 video.pause();
        //             }
        //             break;
        //         case "seeked":
        //             video.pause();
        //             video.currentTime = msg.time;
        //             break;
        //     }
        // })

        socket.on("mouse_dblclk", (msg) => {
            let client_data = clients.get(msg.client_id);

            if (client_data.circle) {
                client_data.circle.remove();
            }

            client_data.circle = new paper.Shape.Circle(new paper.Point(msg.x, msg.y), 50);
            client_data.circle.strokeColor = msg.color;
            client_data.circle.strokeWidth = strokeWidth;
            client_data.circle.tween({ radius: 50 }, { radius: 0 }, 250);
        })

        socket.on("event_mouse", (msg) => {
            let client_id = msg.client_id;
            clients.setne(client_id, { paths: [], shapes: [] })
            let client_data = clients.get(client_id);

            switch (msg.type) {
                case "mousedown":
                    if (msg.tool === "line") {
                        let new_path = new paper.Path()
                        new_path.strokeColor = msg.color;
                        new_path.strokeWidth = 3;
                        new_path.strokeCap = 'round';

                        if (msg.style !== "solid") {
                            new_path.dashArray = [10, 10];
                        }

                        client_data.paths.push(new_path)
                    } else {
                        let rect = new paper.Rectangle();
                        rect.topLeft = new paper.Point(msg.x, msg.y);
                        client_data.rect = rect
                    }
                    break;
                case "mouseup":
                    if (msg.tool === "line") {
                        let newest_path = client_data.paths.last();
                        newest_path.smooth();
                        newest_path.simplify();
                    } else {
                        let ellipse = new paper.Path.Ellipse(client_data.rect);
                        ellipse.strokeColor = msg.color;
                        ellipse.strokeWidth = strokeWidth;

                        if (msg.style !== "solid") {
                            ellipse.dashArray = dash;
                        }

                        if (client_data.ghost) {
                            client_data.ghost.remove();
                        }

                        client_data.shapes.push(ellipse);
                    }
                    break;
                case "mousedrag":
                    if (msg.tool === "line") {
                        client_data.paths.last().add(new paper.Point(msg.x, msg.y));
                    } else {
                        client_data.rect.bottomRight = new paper.Point(msg.x, msg.y);

                        if (client_data.ghost) {
                            client_data.ghost.remove();
                        }

                        let ghostEllipse = new paper.Path.Ellipse(client_data.rect);
                        ghostEllipse.strokeColor = msg.color;
                        ghostEllipse.strokeWidth = strokeWidth;
                        ghostEllipse.opacity = ghostOpacity;

                        if (msg.style !== "solid") {
                            ghostEllipse.dashArray = dash;
                        }

                        client_data.ghost = ghostEllipse;
                    }
                    break;
            }
        })

        socket.on("key_up", (msg) => {
            let client_id = msg.client_id;
            let client_data = clients.get(client_id);

            switch (msg.key) {
                case 'c':
                    if (client_data) {
                        if (client_data.paths) {
                            $.each(client_data.paths, (_, p) => {
                                p.remove();
                            })
                        }

                        if (client_data.shapes) {
                            $.each(client_data.shapes, (_, p) => {
                                p.remove();
                            })
                        }
                    }
                    break;
            }
        })

        socket.on("delete_all", () => {
            clients.forEach((val, _) => {
                $.each(val.paths, (_, path) => {
                    path.remove();
                });
                $.each(val.shapes, (_, shape) => {
                    shape.remove();
                });
            });
        })

        socket.on("mouse_dblclk", (msg) => {
            let client_data = clients.get(msg.client_id);

            if (client_data.circle) {
                client_data.circle.remove();
            }

            client_data.circle = new paper.Shape.Circle(new paper.Point(msg.x, msg.y), 50);
            client_data.circle.strokeColor = msg.color;
            client_data.circle.strokeWidth = strokeWidth;
            client_data.circle.tween({ radius: 50 }, { radius: 0 }, 250);
        })

        paper.view.onKeyDown = (event) => {
            if (event.event.altKey && event.key == 'c') {
                socket.emit("delete_all");
            }
        }

        // paper.view.onKeyUp = (event) => {
        //     socket.emit('key_up', { key: event.key })

        //     switch (event.key) {
        //         case "o":
        //             $('#settingControlsModal').modal('toggle');
        //             break;
        //         case "p":
        //             let isVideoPlaying = video.currentTime > 0 && !video.paused && !video.ended
        //                 && video.readyState > video.HAVE_CURRENT_DATA;

        //             if (!isVideoPlaying) {
        //                 video.play().catch((reason) => { console.log(reason) });
        //             } else {
        //                 video.pause();
        //             }
        //             break;
        //         case "s":
        //             video.pause();
        //             video.currentTime = 0;
        //             break;
        //         case "f":
        //             video.pause();
        //             video.currentTime += 1;
        //             break;
        //         case "b":
        //             video.pause();
        //             video.currentTime -= 1;
        //             break;
        //     }
        // }
    </script>
</body>

</html>